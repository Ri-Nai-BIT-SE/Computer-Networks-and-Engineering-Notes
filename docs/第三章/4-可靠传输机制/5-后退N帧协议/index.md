# 3.4.5 后退N帧协议 (Go-Back-N, GBN)

后退N帧协议是滑动窗口协议的一种具体实现方式。它的接收方逻辑简单，但代价是在出错时效率较低。

### 核心概念

#### 1. GBN 的核心规则

*   **发送窗口**: $W_S > 1$。发送方可以连续发送多个帧。
*   **接收窗口**: $W_R = 1$。**这是 GBN 最关键的特征**。

#### 2. 发送方行为

##### a. 连续发送

*   在发送窗口大小 $W_S$ 的限制内，可以连续发送数据帧。
*   不必等待每一帧的确认，提高了信道利用率。

##### b. 维护一个计时器

*   只为**最早发出的未确认帧**维护一个超时计时器。
*   这简化了实现，减少了系统开销。

##### c. 收到 ACK - 累积确认

*   GBN 采用**累积确认 (Cumulative Acknowledgement)** 方式。
*   收到对帧 $n$ 的确认 (ACK $n$)，意味着接收方已经**正确并按序**收到了**包括 $n$ 在内及之前的所有帧**。
*   此时，发送方可以：
    1.  将窗口滑动到 $n+1$ 的位置。
    2.  重启计时器（如果窗口内还有已发送未确认的帧）。

**示例**：
```
发送窗口: [0 1 2 3 4] 5 6 7 ...
          ↑已发 ↑已发 ↑已发 ↑可发 ↑可发

收到 ACK 2 后:
发送窗口:     [3 4 5 6 7] 8 9 ...
              ↑已发 ↑可发 ↑可发 ↑可发 ↑可发
```

##### d. 计时器超时 - 后退N帧

*   如果计时器超时，发送方认为最早的那个未确认帧已经丢失。
*   此时，它会**重传该帧以及它之后所有已经发送过的帧**。
*   这就是"**后退N帧**"名称的由来。

**示例**：
```
已发送帧: 0 1 2 3 4 5
收到确认: ACK0 ACK1
帧2超时 → 重传: 2 3 4 5 (后退到帧2，重传所有后续帧)
```

#### 3. 接收方行为

由于接收窗口 $W_R = 1$，接收方的行为非常简单：

##### a. 按序接收

*   接收方只维护一个期望接收的帧序号 `expected_seq_num`。
*   初始值为 0。

##### b. 正确到达

*   如果收到的帧序号等于 `expected_seq_num` 且**无差错**，则：
    1.  接收该帧。
    2.  将其数据交给网络层。
    3.  `expected_seq_num` 加 1。
    4.  发送对该帧的 ACK。

##### c. 失序到达 - 全部丢弃

*   如果收到的帧序号**不等于** `expected_seq_num`（即乱序帧）：
    1.  接收方会**直接丢弃该帧**。
    2.  重新发送对**上一个已正确接收帧**的 ACK。
    3.  它**不会**缓存任何失序的帧。

**重要示例**：
```
接收方期望: 帧2
实际收到: 帧3
处理: 丢弃帧3，重发 ACK1

继续收到: 帧4
处理: 丢弃帧4，重发 ACK1

继续收到: 帧5
处理: 丢弃帧5，重发 ACK1

结果: 发送方最终会因帧2超时，重传2、3、4、5所有帧
```

#### 4. GBN 协议工作流程示例

##### 场景：帧2丢失

```
时间  发送方                        接收方
-----|----------------------------|---------------------------
  1  | 发送 帧0                   |
  2  |                            | 收到 帧0，发送 ACK0
  3  | 发送 帧1                   |
  4  |                            | 收到 帧1，发送 ACK1
  5  | 发送 帧2 ----X (丢失)      |
  6  | 发送 帧3                   |
  7  |                            | 收到 帧3 (期望2)
  8  |                            | 丢弃 帧3，重发 ACK1
  9  | 发送 帧4                   |
 10  |                            | 收到 帧4 (期望2)
 11  |                            | 丢弃 帧4，重发 ACK1
 12  | 帧2 超时!                  |
 13  | 重传 帧2、3、4             |
 14  |                            | 收到 帧2，发送 ACK2
 15  |                            | 收到 帧3，发送 ACK3
 16  |                            | 收到 帧4，发送 ACK4
```

#### 5. 优缺点分析

##### 优点

*   **接收端逻辑简单**: 
    *   不需要缓存乱序的帧。
    *   节省了内存。
    *   实现简单。
    
*   **只需一个计时器**: 
    *   降低了发送方的实现复杂度。

##### 缺点

*   **效率低**: 
    *   当信道误码率高或时延带宽积大时。
    *   一个帧的丢失会导致大量后续**正确的帧**被丢弃和重传。
    *   造成巨大的网络资源浪费。
    
*   **带宽浪费**: 
    *   即使只有一个帧出错。
    *   也要重传窗口内的所有帧。

#### 6. 窗口大小限制

*   **序号空间**: 如果帧序号使用 $n$ 个比特，则序号范围是 $0$ 到 $2^n-1$。

*   **窗口大小限制**: 在 GBN 中，发送窗口大小 $W_S$ 必须满足：
    $$1 \le W_S \le 2^n - 1$$

*   **为什么不能 $W_S = 2^n$？**
    *   若 $W_S = 2^n$，会出现无法区分新旧窗口的歧义。
    *   **示例**（$n=2$，序号 0,1,2,3）:
        *   发送方发送 0,1,2,3，窗口满。
        *   所有 ACK 丢失，发送方超时重传 0,1,2,3。
        *   但接收方期望新的 0,1,2,3（下一轮）。
        *   接收方无法区分这是重传的旧帧还是新帧。
    *   因此必须 $W_S \le 2^n - 1 = 3$。

### 易考点 & 难点

*   **易考点**:
    *   GBN 协议的发送窗口和接收窗口大小（$W_S > 1$，$W_R = 1$）。
    *   累积确认的概念和工作方式。
    *   窗口大小限制公式：$W_S \le 2^n - 1$。

*   **难点**:
    *   **GBN 的核心重传逻辑**: 
        *   理解为何一个帧出错/丢失会导致其后所有已发送帧的重传（"Go-Back-N"）。
        *   这是 GBN 的命名由来和核心机制。
        
    *   **接收方的行为**: 
        *   牢记 GBN 接收方**不缓存失序帧，一律丢弃**。
        *   这是它与选择重传协议的根本区别。
        *   也是考试的重点。
        
    *   **窗口大小的限制**: 
        *   理解 $W_S$ 为何不能等于 $2^n$。
        *   能够用具体例子说明会产生的歧义。
        
    *   **协议交互过程分析**: 
        *   能够画出发生帧丢失、ACK 丢失时的详细时序图。
        *   正确描述窗口的滑动过程。
