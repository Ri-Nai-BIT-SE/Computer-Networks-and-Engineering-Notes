# 3.4.6 选择重传协议 (Selective Repeat, SR)

选择重传协议是对 GBN 的改进，它通过让接收方缓存失序帧，实现了只重传真正丢失或出错的帧，从而大大提高了效率。

### 核心概念

#### 1. SR 的核心规则

*   **发送窗口**: $W_S > 1$。
*   **接收窗口**: $W_R > 1$。**这是 SR 最关键的特征**。

#### 2. 发送方行为

##### a. 连续发送

*   在发送窗口 $W_S$ 范围内连续发送帧。
*   与 GBN 类似，但重传策略完全不同。

##### b. 维护多个计时器

*   为**每一个已发送但未确认的帧**都设置一个独立的超时计时器。
*   这是与 GBN（只有一个计时器）的重要区别。
*   实现较复杂，但能精确控制每个帧的重传。

##### c. 收到 ACK - 单个确认

*   SR 采用**单个确认**方式（与 GBN 的累积确认不同）。
*   收到 ACK $n$ 只表示**帧 $n$ 已被正确接收**。
*   发送方的处理：
    1.  将该帧标记为已接收，取消其计时器。
    2.  如果该帧是窗口的下界（最左边的帧），则发送窗口可以向前滑动。
    3.  滑动直到遇到第一个未被确认的帧。

**示例**：
```
发送窗口: [0 1 2 3 4] 5 6 7 ...
收到: ACK1
窗口状态: [0✓ 1✓ 2 3 4] (帧1已确认，但帧0未确认，窗口不滑动)

收到: ACK0
窗口滑动:   [2 3 4 5 6] 7 8 ... (帧0、1都已确认，窗口滑动到帧2)
```

##### d. 计时器超时 - 选择重传

*   如果某个帧（例如帧 $k$）的计时器超时：
    *   发送方**只重传帧 $k$**。
    *   **不会**重传它之后已经发送过的帧。
    *   这就是"**选择重传**"的含义。

**对比 GBN**：
```
GBN:  帧2超时 → 重传 2, 3, 4, 5 (所有后续帧)
SR:   帧2超时 → 重传 2 (仅重传丢失的帧)
```

#### 3. 接收方行为

由于接收窗口 $W_R > 1$，接收方的行为更加复杂：

##### a. 可接收乱序帧

*   只要收到的帧序号**落在接收窗口 $W_R$ 内**且**无差错**：
    1.  接收方就会接收它。
    2.  发送对该帧的 ACK。
    3.  如果该帧不是期望的按序帧，接收方会将其**缓存**起来。

**示例**：
```
接收窗口: [2 3 4 5 6]
期望帧: 2

收到帧4: 
  - 在窗口内，接收并缓存
  - 发送 ACK4
  - 期望帧仍为2

收到帧5:
  - 在窗口内，接收并缓存
  - 发送 ACK5
  - 期望帧仍为2
```

##### b. 滑动窗口与交付数据

*   当接收方收到了窗口下界所期望的那个帧后（补上了之前丢失的帧）：
    1.  检查缓存，找出**从窗口下界开始的连续帧**。
    2.  将这批连续的帧一起交付给网络层。
    3.  接收窗口向前滑动到下一个未收到的帧的位置。

**完整示例**：
```
接收窗口: [2 3 4 5 6]
缓存: 4, 5 (已收到但未交付)

收到帧3:
  - 接收并缓存
  - 发送 ACK3
  - 缓存: 3, 4, 5

收到帧2:
  - 接收
  - 发送 ACK2
  - 发现连续: 2, 3, 4, 5
  - 将帧2, 3, 4, 5一起交付给网络层
  - 窗口滑动: [6 7 8 9 10]
```

##### c. 窗口外的帧处理

*   如果收到的帧序号**小于**接收窗口下界：
    *   说明这是一个已经确认过的旧帧（迟到的重传帧）。
    *   **丢弃该帧**，但**重发 ACK**（因为可能之前的 ACK 丢失了）。

*   如果收到的帧序号**大于**接收窗口上界：
    *   说明这个帧过于超前。
    *   **丢弃该帧**。

#### 4. SR 协议工作流程示例

##### 场景：帧2丢失

```
时间  发送方                        接收方（窗口 [2 3 4 5 6]）
-----|----------------------------|---------------------------
  1  | 发送 帧0                   |
  2  |                            | 收到 帧0，交付，ACK0，窗口→[1 2 3 4 5]
  3  | 发送 帧1                   |
  4  |                            | 收到 帧1，交付，ACK1，窗口→[2 3 4 5 6]
  5  | 发送 帧2 ----X (丢失)      |
  6  | 发送 帧3                   |
  7  |                            | 收到 帧3 (在窗口内)
  8  |                            | 缓存 帧3，发送 ACK3
  9  | 发送 帧4                   |
 10  |                            | 收到 帧4 (在窗口内)
 11  |                            | 缓存 帧4，发送 ACK4
 12  | 帧2 超时!                  |
 13  | 仅重传 帧2                 |
 14  |                            | 收到 帧2
 15  |                            | 发现连续: 2, 3, 4
 16  |                            | 交付 2, 3, 4，发送 ACK2
 17  |                            | 窗口→[5 6 7 8 9]
```

#### 5. 优缺点分析

##### 优点

*   **效率高**: 
    *   只重传真正丢失或出错的帧。
    *   避免了 GBN 中重传大量正确帧的浪费。
    *   在高误码率或大时延带宽积的信道上优势明显。
    
*   **带宽利用率高**: 
    *   减少了不必要的重传。
    *   网络资源利用更合理。

##### 缺点

*   **实现复杂**: 
    *   发送方需要为每个帧维护独立的计时器。
    *   接收方需要维护一个大小为 $W_R$ 的缓存区。
    *   需要更多的内存和计算资源。
    
*   **接收方复杂**: 
    *   需要缓存失序帧。
    *   需要检测并交付连续的帧序列。
    *   逻辑比 GBN 复杂得多。

#### 6. 窗口大小限制 ⭐ 重点

这是 SR 协议最微妙也最重要的一点。

##### 基本限制

为了避免新旧窗口的序号重叠造成歧义，发送窗口和接收窗口的大小必须满足：

$$W_S + W_R \le 2^n$$

其中 $n$ 是序列号的比特数。

##### 常见设计

在通常的设计中，令 $W_S = W_R$，则有：

$$W_S \le 2^{n-1}$$

即窗口大小不能超过序号空间的一半。

##### 为什么需要这个限制？

**反例**（$n=2$，序号 0,1,2,3，$W_S = W_R = 3$）：

```
发送方发送窗口: [0 1 2]
接收方接收窗口: [0 1 2]

情况1: 正常接收
  - 接收方收到 0, 1, 2，全部确认
  - 发送 ACK0, ACK1, ACK2
  - 接收窗口滑动到 [3 0 1]

情况2: 所有 ACK 丢失
  - 发送方未收到任何 ACK
  - 超时后重传 0, 1, 2
  - 接收方窗口是 [3 0 1]
  - 接收方收到帧0:
    * 帧0在窗口内 → 接收方会认为这是新的帧0（第二轮）
    * 实际上这是重传的旧帧0
  - 产生歧义！接收方无法区分新旧帧

解决方案: 限制 WS + WR ≤ 4，例如 WS = WR = 2
```

**正确示例**（$n=2$，$W_S = W_R = 2$）：

```
发送窗口: [0 1] 2 3
接收窗口: [0 1] 2 3

所有 ACK 丢失，重传 0, 1
接收方窗口已滑动到 [2 3]
收到旧的帧0: 在窗口外 → 正确识别为旧帧，丢弃
```

##### 关键结论

*   如果违反这个规则，接收方将**无法判断**一个到来的帧是**新帧**还是**迟到的重传帧**。
*   这是 SR 协议设计中最关键的约束条件。

### 三种 ARQ 协议对比总结

| 特性 | 停-等协议 (Stop-and-Wait) | 后退N帧 (GBN) | 选择重传 (SR) |
|:---|:---|:---|:---|
| **发送窗口 $W_S$** | $W_S = 1$ | $1 < W_S \le 2^n-1$ | $1 < W_S \le 2^{n-1}$ |
| **接收窗口 $W_R$** | $W_R = 1$ | $W_R = 1$ | $1 < W_R \le 2^{n-1}$ |
| **确认机制** | 单个确认 | 累积确认 | 单个确认 |
| **计时器** | 1个 | 1个（最早未确认帧） | 多个（每个已发送帧） |
| **重传策略** | 超时重传当前帧 | 超时重传窗口内所有已发送帧 | 超时只重传对应的单个帧 |
| **接收方缓存** | 不需要 | 不需要 | 需要，大小为 $W_R$ |
| **失序帧处理** | 丢弃 | 丢弃，重发上次ACK | 缓存，发送对应ACK |
| **信道利用率** | 极低 | 中等（误码率低时高） | 高 |
| **优点** | 简单 | 接收方简单 | 效率高，带宽利用好 |
| **缺点** | 效率极低 | 错误信道下效率低，浪费带宽 | 实现复杂（多计时器、缓存） |
| **适用场景** | 低速、短距离 | 误码率低的信道 | 高速、长距离、高误码率 |

### 易考点 & 难点

*   **易考点**:
    *   SR 协议的核心思想（只重传坏帧/丢失帧）。
    *   SR 协议的发送窗口和接收窗口大小（都大于1）。
    *   SR 与 GBN 的基本区别（窗口大小、确认方式、重传策略、缓存）。
    *   窗口大小限制公式：$W_S + W_R \le 2^n$ 或 $W_S \le 2^{n-1}$。

*   **难点**:
    *   **SR 的窗口大小限制**: 
        *   $W_S + W_R \le 2^n$（或 $W_S \le 2^{n-1}$）是**最重要的考点**。
        *   必须能够解释为何需要这个限制（防止新旧帧歧义）。
        *   能够用具体例子说明违反限制会产生什么问题。
        
    *   **与 GBN 的全面对比**: 
        *   能够清晰地阐述 SR 和 GBN 在以下方面的**全部区别**：
            *   发送方：计时器数量、重传范围、ACK 处理方式
            *   接收方：$W_R$ 大小、是否缓存、失序帧处理、ACK 类型
        
    *   **协议交互过程分析**: 
        *   能够画出 SR 协议下，发生帧丢失、乱序时的详细时序图。
        *   正确描述发送方和接收方窗口的变化。
        *   理解接收方何时交付数据、何时滑动窗口。
        
    *   **接收窗口的滑动时机**: 
        *   理解接收方必须等到收到窗口下界的帧后。
        *   才能将连续的帧一起交付并滑动窗口。
        *   这是 SR 协议正确性的关键。
