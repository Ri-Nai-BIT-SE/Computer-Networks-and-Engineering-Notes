# 5.9.2 TCP 的连接释放 (Connection Release)

这一节俗称 **"四次挥手 (Four-Way Wave)"**。

相比于三次握手，连接释放的过程更复杂，因为 TCP 是 **全双工 (Full-Duplex)** 的。
* **全双工意味着**：A 可以给 B 发数据，B 也可以给 A 发数据。这两条通道是独立的。
* **释放逻辑**：A 说"我不发了"（关一半），B 说"好的"。然后 B 说"我也不发了"（关另一半），A 说"好的"。一共 4 步。

这一节的**超级考点**是：**TIME-WAIT 状态** 和 **2MSL 时间**。

---

## 🟢 [交互演示]：四次挥手模拟器

这个演示展示了**主动关闭方（Client）**和**被动关闭方（Server）**的状态变化。

<TCPFourWayHandshake />

**重点观察**：
1. **CLOSE-WAIT**：服务器收到 FIN 后，不能马上关，还要把没发完的数据发完。
2. **TIME-WAIT**：客户端发完最后一个 ACK 后，**并没有直接 CLOSED**，而是亮起了倒计时。

---

## 📚 详细流程解析 (必背考点)

假设客户端 A 主动关闭，服务器 B 被动关闭。

### 第一步 (A → B): 客户端请求关闭

* **报文**：`FIN = 1, seq = u`
  * *注意*：`FIN` 报文即使不携带数据，也要**消耗一个序号**。
* **状态**：A 进入 **FIN-WAIT-1**。
* **含义**："我的数据发完了，我要关闭连接。"

### 第二步 (B → A): 服务器确认

* **报文**：`ACK = 1, seq = v, ack = u + 1`
* **状态**：
  * B 进入 **CLOSE-WAIT** (关闭等待)
  * A 收到后进入 **FIN-WAIT-2**
* **关键点**：此时处于 **"半关闭" (Half-close)** 状态。
  * A 不能给 B 发数据了。
  * B **还可以**给 A 发数据（比如处理完剩下的任务），A 必须接收。

### 第三步 (B → A): 服务器请求关闭

* **前提**：B 的数据终于发完了。
* **报文**：`FIN = 1, ACK = 1, seq = w, ack = u + 1`
  * *注意*：因为半关闭期间 A 没发新数据，所以 `ack` 还是 `u+1`。
* **状态**：B 进入 **LAST-ACK** (最后确认)。
* **含义**："我的数据也发完了，我也要关闭连接。"

### 第四步 (A → B): 客户端确认

* **报文**：`ACK = 1, seq = u + 1, ack = w + 1`
* **状态**：
  * B 收到 ACK → **CLOSED** (B 自由了)。
  * A 发出 ACK → **TIME-WAIT** (A 还要等！)。

---

## 🎓 终极考点：TIME-WAIT 状态

这是关于四次挥手**被问得最多**的问题，没有之一。

### 问题 1：TIME-WAIT 是谁的状态？

* **答**：是**主动关闭方**（客户端 A）的状态。

### 问题 2：为什么要等？等多久？

* **时长**：**2MSL** (Maximum Segment Lifetime，最长报文段寿命)。通常是 2分钟或 4分钟。
* **原因 A（为了可靠）**：
  * 万一 A 发的**最后一个 ACK 丢了**怎么办？
  * B 会收不到确认，超时重发 `FIN`。
  * 如果 A 早就跑了（CLOSED），B 就会收到错误回复（RST）。
  * 所以 A 必须多留一会儿，帮 B 兜底，确保 B 能收到确认并正常关闭。
* **原因 B（为了防乱入）**：
  * 防止"已失效的连接请求报文段"出现在下一个新连接中。
  * 等待 2MSL 可以让本次连接中产生的所有报文段都在网络中**消失**（老死）。

### 问题 3：保活计时器 (Keep-alive Timer)

* **场景**：连接建好了，客户端突然**死机**了，服务器怎么办？总不能一直等吧？
* **机制**：
  * 服务器每收到一次数据就重置计时器（通常 2 小时）。
  * 如果 2 小时没动静，发送探测报文。
  * 如果连续 10 个探测没反应，服务器就断开连接。

---

## 📊 状态变迁总结

| 步骤 | 客户端状态 | 服务器状态 | 说明 |
| :--- | :--- | :--- | :--- |
| 初始 | ESTABLISHED | ESTABLISHED | 正常传输数据 |
| 第1次挥手后 | FIN-WAIT-1 | ESTABLISHED | 客户端发送 FIN |
| 第2次挥手后 | FIN-WAIT-2 | CLOSE-WAIT | 服务器回复 ACK（半关闭） |
| 第3次挥手后 | TIME-WAIT | LAST-ACK | 服务器发送 FIN |
| 第4次挥手后 | TIME-WAIT | CLOSED | 客户端发送 ACK |
| 2MSL 后 | CLOSED | CLOSED | 连接彻底关闭 |

---

## 🎓 考试必背考点

### 考点一：为什么是4次不是3次？

* **题目**：为什么TCP连接释放需要4次挥手，而不是3次？
* **答**：因为TCP是全双工的，需要分别关闭两个方向的数据传输。第二次挥手的ACK和第三次挥手的FIN不能合并，因为服务器可能还有数据要发送（半关闭状态）。

### 考点二：TIME-WAIT 状态

* **题目**：TIME-WAIT 状态是谁的状态？为什么要等待？
* **答**：
  - 是**主动关闭方**的状态
  - 等待 **2MSL** 时间
  - 原因1：确保最后一个ACK能到达，如果丢失可以重传
  - 原因2：让本次连接的所有报文段在网络中消失，防止影响新连接

### 考点三：半关闭状态

* **题目**：什么是半关闭状态？
* **答**：在CLOSE-WAIT状态时，A→B方向已关闭，但B→A方向还可以继续发送数据。这是TCP全双工特性的体现。

### 考点四：序号计算

* **题目**：客户端初始序号 u=100，服务器初始序号 v=200，w=300，求四次挥手中各报文的序号和确认号。
* **答**：
  - 第1次：seq=u=100, ack=无（FIN=1）
  - 第2次：seq=v=200, ack=u+1=101
  - 第3次：seq=w=300, ack=u+1=101（半关闭期间A没发数据）
  - 第4次：seq=u+1=101, ack=w+1=301

### 考点五：FIN 报文消耗序号

* **题目**：四次挥手中，哪些报文段消耗序号？
* **答**：**第1次和第3次**（FIN=1的报文段）。第2次和第4次的ACK如果不携带数据，不消耗序号。

---

## 🎯 易错点提醒

1. **FIN 报文消耗序号**：
   - 第1次和第3次挥手的 FIN 报文都要消耗 1 个序号
   - 即使不携带数据，FIN 本身也要消耗序号

2. **半关闭状态**：
   - CLOSE-WAIT 时，A→B 已关闭，但 B→A 还能发数据
   - 这是TCP全双工特性的体现

3. **TIME-WAIT 的必要性**：
   - 不是可选的，是必须的
   - 等待 2MSL 时间，确保可靠关闭

4. **状态名称**：
   - FIN-WAIT-1：等待对方的确认
   - FIN-WAIT-2：等待对方的FIN
   - CLOSE-WAIT：等待应用层关闭
   - LAST-ACK：等待最后的确认
   - TIME-WAIT：等待 2MSL 时间

5. **为什么是4次不是3次**：
   - 因为ACK和FIN不能合并（半关闭状态）
   - 如果服务器没有数据要发，理论上可以合并，但TCP标准要求分开

---

## 总结

**核心要点**：
1. **四次挥手**：FIN → ACK → FIN → ACK
2. **半关闭**：CLOSE-WAIT 状态，B→A 还能发数据
3. **TIME-WAIT**：主动关闭方必须等待 2MSL 时间
4. **为什么4次**：全双工特性，需要分别关闭两个方向

**必背公式**：
- 第1次：FIN=1, seq=u
- 第2次：ACK=1, seq=v, ack=u+1
- 第3次：FIN=1, ACK=1, seq=w, ack=u+1
- 第4次：ACK=1, seq=u+1, ack=w+1

**关键记忆**：
- **"四次"** 是因为中间有个 **半关闭** 状态（ACK 和 FIN 分开发）。
- **TIME-WAIT** 是主动方的必修课，必须等 **2MSL** 才能关。
- **FIN** 报文要消耗 1 个序号。


