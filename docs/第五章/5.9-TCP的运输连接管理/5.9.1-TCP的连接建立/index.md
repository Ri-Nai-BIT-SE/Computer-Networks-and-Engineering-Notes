# 5.9.1 TCP 的连接建立 (Connection Establishment)

这一节是计算机网络面试和考试中**出镜率最高**的知识点，俗称 **"三次握手 (Three-Way Handshake)"**。

无论是选择题考状态变迁，还是大题考序号计算，这一节都是必须要拿满分的。

---

## 1. 为什么叫"握手"？

TCP 是面向连接的协议。在传数据之前，必须先打招呼，协商好双方的**初始序号 (seq)**、**窗口大小 (rwnd)** 等参数。这个过程就叫握手。

---

## 🟢 [交互演示]：三次握手模拟器

这个演示展示了客户端（Client）和服务器（Server）在握手过程中的**状态变化**和**报文内容**。

<TCPThreeWayHandshake />

**操作说明**：
1. 点击"下一步"，像播放 PPT 一样观察流程
2. **重点观察**：
   - **状态变化**（从 CLOSED 到 ESTABLISHED）
   - **ack 的计算**（为什么是 x+1？）
   - **标志位的变化**（SYN、ACK）

---

## 2. 核心流程：三报文握手 (★ 必背时序图)

请死记硬背以下三个步骤的 **标志位 (SYN/ACK)**、**序号变化 (seq/ack)** 和 **状态变迁**。

假设客户端初始序号为 $x$，服务器初始序号为 $y$。

### **第 1 次握手 (Client → Server)**

* **报文内容**：
  - `SYN = 1`
  - `seq = x`
  - *注意*：这里不能携带数据，但**要消耗掉 1 个序号**。
* **状态**：客户端进入 **SYN-SENT**（同步已发送）。
* **含义**："你好，我要和你建立连接。"

### **第 2 次握手 (Server → Client)**

* **报文内容**：
  - `SYN = 1`, `ACK = 1`
  - `seq = y`, `ack = x + 1`
  - *ACK=1*：表示确认有效。
  - *ack=x+1*：表示"收到你的序号 x 了，下次请发 x+1"。
  - *SYN=1*：表示"我也要和你建立连接"。
  - *seq=y*：服务器自己的初始序号。
  - *注意*：这个报文也要**消耗掉 1 个序号**。
* **状态**：服务器进入 **SYN-RCVD**（同步收到）。
* **含义**："收到，我也同意。这是我的序号。"

### **第 3 次握手 (Client → Server)**

* **报文内容**：
  - `ACK = 1`
  - `seq = x + 1`, `ack = y + 1`
  - *seq=x+1*：响应服务器的请求（上次你说下次发 x+1）。
  - *ack=y+1*：确认收到服务器的 y。
  - *注意*：**ACK 报文段如果不携带数据，则不消耗序号**。所以下一个数据报文的 `seq` 依然是 `x+1`。
* **状态**：
  * 客户端发完包后，进入 **ESTABLISHED**（已建立连接）。
  * 服务器收到包后，进入 **ESTABLISHED**。
* **含义**："收到你的同意了，咱开始传数据吧。"

---

## 3. 状态变迁总结

| 步骤 | 客户端状态 | 服务器状态 | 说明 |
| :--- | :--- | :--- | :--- |
| 初始 | CLOSED | LISTEN | 服务器监听，等待连接 |
| 第1次握手后 | SYN-SENT | LISTEN | 客户端发送 SYN |
| 第2次握手后 | SYN-SENT | SYN-RCVD | 服务器回复 SYN+ACK |
| 第3次握手后 | ESTABLISHED | ESTABLISHED | 连接建立完成 |

---

## 4. 经典面试/考试题：为什么是 3 次？

如果只握手 **2 次**，会发生什么？

### 场景（失效报文）

1. 客户端发了第一个 SYN 请求（A），但在网络中**滞留**了，没到服务器。
2. 客户端超时重发了第二个 SYN 请求（B），服务器收到了，建立了连接，传输完数据，**关闭了连接**。
3. **这就是问题所在**：过了一会儿，那个滞留的 SYN 请求（A）终于慢吞吞地到了服务器。

### 后果

* **如果是 2 次握手**：
  * 服务器收到旧的请求（A），以为客户端又要建立新连接，于是立刻同意，进入 ESTABLISHED 状态，并**一直等待客户端发数据**。
  * 但客户端并没有想发数据（它早就结束了）。
  * **结果**：服务器白白浪费资源（死锁）。

* **如果是 3 次握手**：
  * 服务器收到旧请求（A），发回确认（SYN+ACK）。
  * 客户端收到确认，发现："咦？我没想建立连接啊（或者这是个旧的）？"
  * 客户端发送 **RST (Reset)** 报文，拒绝连接。
  * 服务器收到 RST，知道搞错了，关闭连接。**资源未浪费**。

**总结**：三次握手的主要目的是为了防止"已失效的连接请求报文段"突然又传送到了服务端，产生错误。

---

## 🎓 考试必背考点

### 考点一：三次握手的标志位

* **题目**：三次握手中，哪些报文段的 SYN=1？
* **答**：**第1次和第2次**。第3次只有 ACK=1。

### 考点二：序号的计算

* **题目**：客户端初始序号 x=100，服务器初始序号 y=200，求三次握手中各报文的序号和确认号。
* **答**：
  - 第1次：seq=x=100, ack=无（ACK=0）
  - 第2次：seq=y=200, ack=x+1=101
  - 第3次：seq=x+1=101, ack=y+1=201

### 考点三：状态变迁

* **题目**：服务器在收到第1次握手后进入什么状态？
* **答**：**SYN-RCVD**（同步收到）

### 考点四：为什么是3次

* **题目**：为什么TCP连接建立需要3次握手，而不是2次？
* **答**：防止已失效的连接请求报文段突然传送到服务器，导致服务器资源浪费。

### 考点五：序号消耗

* **题目**：三次握手中，哪些报文段消耗序号？
* **答**：**第1次和第2次**（SYN=1的报文段）。第3次如果只发ACK不携带数据，不消耗序号。

---

## 🎯 易错点提醒

1. **SYN 报文消耗序号**：
   - 第1次和第2次握手的 SYN 报文都要消耗 1 个序号
   - 即使不携带数据，SYN 本身也要消耗序号

2. **ACK 报文不消耗序号**：
   - 第3次握手的 ACK 如果不携带数据，不消耗序号
   - 下一个数据报文的 seq 依然是 x+1

3. **确认号的含义**：
   - ack=x+1 表示"收到序号 x，期望收到 x+1"
   - 这是累积确认的体现

4. **状态名称**：
   - SYN-SENT：同步已发送（客户端）
   - SYN-RCVD：同步收到（服务器）
   - ESTABLISHED：已建立连接（双方）

5. **为什么是3次不是2次**：
   - 防止失效连接请求导致服务器资源浪费
   - 这是考试常考的解释题

---

## 总结

**核心要点**：
1. **三次握手**：Client → Server (SYN), Server → Client (SYN+ACK), Client → Server (ACK)
2. **状态变迁**：CLOSED → SYN-SENT → ESTABLISHED（客户端）
3. **序号消耗**：SYN 报文消耗序号，纯 ACK 不消耗序号
4. **为什么3次**：防止失效连接请求导致资源浪费

**必背公式**：
- 第1次：SYN=1, seq=x
- 第2次：SYN=1, ACK=1, seq=y, ack=x+1
- 第3次：ACK=1, seq=x+1, ack=y+1


