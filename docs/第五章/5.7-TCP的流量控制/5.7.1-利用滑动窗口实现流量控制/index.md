# 5.7.1 利用滑动窗口实现流量控制

这一节的内容非常直观，它解决的是**"发送方太快，接收方消化不了"**的问题。

* **流量控制 (Flow Control)**：让发送方的发送速率不要太快，要让接收方来得及接收。
* **核心手段**：利用 TCP 首部中的 **窗口 (Window)** 字段（即 `rwnd`）。

这一节在考试中主要考**逻辑分析**（比如给出场景让你判断能不能发）和**死锁问题**（零窗口探测）。

---

## 🟢 [交互演示]：流量控制模拟器

这个演示非常关键，它展示了**"接收缓存"**是如何直接决定**"发送窗口"**的。

<TCPFlowControl />

**操作说明**：
1. 点击"发送 1 个数据包"，观察接收缓存被填满，rwnd 变小
2. 当 rwnd = 0 时，发送方必须停止发送（零窗口）
3. 点击"应用层读取 1 个包"，模拟接收方软件把数据拿走
4. 观察 rwnd 变大，发送方又可以发送了

---

## 📚 核心考点笔记

### 1. 流量控制的本质

* **机制**：利用 TCP 首部中的 **窗口 (Window)** 字段。
* **逻辑**：
  * 接收方在 ACK 报文中，将自己当前的 **接收窗口 rwnd (Receiver Window)** 值告诉发送方。
  * **发送方窗口的上限值 = Min [ rwnd, cwnd ]**。
    * `rwnd`: 接收方给的（流量控制）。
    * `cwnd`: 网络给的（拥塞控制，5.8节讲）。
    * *在流量控制这一节，通常假设网络不堵，即发送窗口 = rwnd。*

### 2. rwnd 的计算

* **公式**：$rwnd = 接收缓存总容量 - 已占用的缓存$
* **含义**：接收方告诉发送方"我还能接收多少字节"。
* **动态变化**：
  * 发送方发送数据 → 接收缓存被占用 → rwnd 减小
  * 应用层读取数据 → 接收缓存释放 → rwnd 增大

### 3. 死锁危机：零窗口 (Zero Window)

这是本节最喜欢考的**逻辑陷阱题**。

#### 场景描述

1. B 的缓存满了，发了一个 `rwnd = 0` 的报文给 A。
2. A 收到后，乖乖**停止发送**，等待 B 有空间了通知它。
3. 过了一会儿，B 的应用层读走了数据，B 发了一个 `rwnd = 100` 的报文叫 A 继续发。
4. **关键点：** 这个 `rwnd = 100` 的报文在路上 **丢失了！**

#### 结果（死锁）

* A 还在等 B 的通知（以为 B 还是满的）。
* B 以为 A 收到了通知，在等 A 发数据。
* 两人互相等待，直到天荒地老。

### 4. 解决方案：持续计时器 (Persistence Timer)

为了打破上面的死锁，TCP 设计了一个专门的计时器。

#### 规则

* 只要 TCP 连接的一方收到了对方的 **零窗口通知**，就启动持续计时器。

#### 动作

* 若时间到期，发送一个 **零窗口探测报文段 (Zero Window Probe)**（仅携带 1 字节数据）。
* 对方收到探测报文后，必须回复当前的窗口值。
  * 如果还是 0，重设计时器继续等。
  * 如果不是 0，死锁解除，恢复传输。

#### 计时器设置

* 初始值：通常设置为 RTO（超时重传时间）。
* 超时后：指数退避，每次翻倍（类似 Karn 算法）。

---

## 🎓 考试避坑指南

### 考点一：rwnd 的计算

* **题目**：接收方缓存总容量 1000 字节，已占用 300 字节，求 rwnd。
* **答**：$rwnd = 1000 - 300 = 700$ 字节

### 考点二：发送窗口的限制

* **题目**：已知 rwnd = 500，cwnd = 300，求发送窗口大小。
* **答**：发送窗口 = min(500, 300) = **300**（取较小值）

### 考点三：零窗口死锁

* **题目**：接收方发送 rwnd = 0 后，应用层读取了数据，发送 rwnd = 100 的报文，但该报文丢失了。会发生什么？
* **答**：**死锁**。发送方等待窗口打开，接收方等待数据，互相等待。

### 考点四：持续计时器

* **题目**：如何解决零窗口死锁问题？
* **答**：使用**持续计时器**。收到零窗口通知后启动计时器，超时后发送**零窗口探测报文**。

### 考点五：零窗口探测报文

* **题目**：零窗口探测报文携带多少数据？
* **答**：**1 字节**（仅用于探测，不消耗序号）

---

## 🎯 易错点提醒

1. **区分两个概念**：
   * **流量控制**：是点对点的（A 和 B 两个人的事），为了照顾**接收方**慢。
   * **拥塞控制**：是全局的（大家的事），为了照顾**网络**堵。

2. **发送窗口的确定**：
   * 发送窗口 = min(rwnd, cwnd)
   * 流量控制只考虑 rwnd，拥塞控制考虑 cwnd

3. **零窗口探测报文的序号**：
   * 零窗口探测报文虽然携带 1 字节数据，但通常**不消耗序号**（或者说，如果对方还是零窗口，这 1 字节不会被确认，下次还得重传）。这部分细节考研会考，期末考试只需知道"会发探测报文"即可。

4. **持续计时器的启动时机**：
   * 只有收到**零窗口通知**时才启动
   * 不是每次发送数据都启动

5. **rwnd 的动态变化**：
   * rwnd 不是固定的，会随着接收缓存的使用情况动态变化
   * 每次发送 ACK 时，都会带上当前的 rwnd 值

---

## 总结

**一句话总结**：流量控制就是 B 告诉 A "我还能吃多少"，如果 B 说"吃不下了(rwnd=0)"，A 就要每隔一会问一次"现在能吃了吗？"（持续计时器）。

**核心要点**：
1. **机制**：通过 TCP 首部的窗口字段 (rwnd) 实现
2. **计算**：rwnd = 接收缓存总容量 - 已占用
3. **死锁**：零窗口通知丢失会导致死锁
4. **解决**：持续计时器 + 零窗口探测报文


